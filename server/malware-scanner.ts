import { createHash } from 'crypto';
import { readFile } from 'fs/promises';

interface ScanResult {
  clean: boolean;
  threats: string[];
  scanTime: number;
  fileHash: string;
}

/**
 * Malware Scanner Service
 * Provides file scanning capabilities before data processing
 */
export class MalwareScanner {
  private static readonly SUSPICIOUS_PATTERNS = [
    // Script injection patterns
    /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    /javascript:/gi,
    /vbscript:/gi,
    /data:text\/html/gi,
    
    // File execution patterns
    /\.exe$/i,
    /\.bat$/i,
    /\.cmd$/i,
    /\.scr$/i,
    /\.com$/i,
    /\.pif$/i,
    
    // Macro patterns (for Office files)
    /Sub\s+\w+\(/gi,
    /Function\s+\w+\(/gi,
    /Shell\s*\(/gi,
    /CreateObject\s*\(/gi,
    
    // SQL injection patterns
    /union\s+select/gi,
    /drop\s+table/gi,
    /delete\s+from/gi,
    /insert\s+into/gi,
    /update\s+.*set/gi,
  ];

  private static readonly ALLOWED_MIME_TYPES = [
    'text/csv',
    'application/json',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'text/plain',
    'application/octet-stream', // for files without proper MIME type
  ];

  /**
   * Scan file for malicious content
   */
  static async scanFile(filePath: string, mimeType?: string): Promise<ScanResult> {
    const startTime = Date.now();
    const threats: string[] = [];

    try {
      // Check MIME type first
      if (mimeType && !this.ALLOWED_MIME_TYPES.includes(mimeType)) {
        threats.push(`Disallowed file type: ${mimeType}`);
      }

      // Read and hash file
      const fileBuffer = await readFile(filePath);
      const fileHash = createHash('sha256').update(fileBuffer).digest('hex');
      const fileContent = fileBuffer.toString('utf8', 0, Math.min(fileBuffer.length, 1024 * 1024)); // First 1MB only

      // Check for suspicious patterns
      for (const pattern of this.SUSPICIOUS_PATTERNS) {
        if (pattern.test(fileContent)) {
          threats.push(`Suspicious pattern detected: ${pattern.source.substring(0, 50)}...`);
        }
      }

      // Check file size (prevent extremely large files)
      if (fileBuffer.length > 500 * 1024 * 1024) { // 500MB limit
        threats.push('File too large - potential DoS attempt');
      }

      // Check for null bytes (often used in file upload attacks)
      if (fileBuffer.includes(Buffer.from([0x00]))) {
        threats.push('Null bytes detected - potential file upload attack');
      }

      // Additional checks for CSV/Excel files
      await this.scanDataFile(fileContent, threats);

      const scanTime = Date.now() - startTime;

      return {
        clean: threats.length === 0,
        threats,
        scanTime,
        fileHash,
      };
    } catch (error) {
      return {
        clean: false,
        threats: [`Scan error: ${error.message}`],
        scanTime: Date.now() - startTime,
        fileHash: '',
      };
    }
  }

  /**
   * Additional scanning for data files
   */
  private static async scanDataFile(content: string, threats: string[]): Promise<void> {
    // Check for excessive formula complexity (Excel formula injection)
    const formulaCount = (content.match(/=\w+\(/g) || []).length;
    if (formulaCount > 100) {
      threats.push('Excessive Excel formulas detected - potential formula injection');
    }

    // Check for suspicious URLs in data
    const urlPattern = /https?:\/\/[^\s"'<>]+/gi;
    const urls = content.match(urlPattern) || [];
    for (const url of urls) {
      if (this.isSuspiciousUrl(url)) {
        threats.push(`Suspicious URL detected: ${url.substring(0, 50)}...`);
      }
    }

    // Check for base64 encoded content (potential payload)
    const base64Pattern = /[A-Za-z0-9+\/]{100,}={0,2}/g;
    const base64Matches = content.match(base64Pattern) || [];
    if (base64Matches.length > 10) {
      threats.push('Excessive base64 content detected - potential encoded payload');
    }
  }

  /**
   * Check if URL is suspicious
   */
  private static isSuspiciousUrl(url: string): boolean {
    const suspiciousDomains = [
      'bit.ly',
      'tinyurl.com',
      't.co',
      'goo.gl',
      'ow.ly',
      'is.gd',
    ];

    const domain = url.match(/https?:\/\/([^\/]+)/)?.[1]?.toLowerCase();
    return suspiciousDomains.some(suspicious => domain?.includes(suspicious));
  }

  /**
   * Quick file type validation
   */
  static validateFileType(filename: string, mimeType?: string): { valid: boolean; message?: string } {
    const allowedExtensions = ['.csv', '.xlsx', '.xls', '.json', '.txt'];
    const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));

    if (!allowedExtensions.includes(extension)) {
      return {
        valid: false,
        message: `File type ${extension} not allowed. Supported formats: ${allowedExtensions.join(', ')}`
      };
    }

    if (mimeType && !this.ALLOWED_MIME_TYPES.includes(mimeType)) {
      return {
        valid: false,
        message: `MIME type ${mimeType} not allowed`
      };
    }

    return { valid: true };
  }

  /**
   * Generate scan report
   */
  static generateScanReport(result: ScanResult): string {
    const status = result.clean ? '✅ CLEAN' : '⚠️ THREATS DETECTED';
    const threats = result.threats.length > 0 
      ? `\nThreats:\n${result.threats.map(t => `- ${t}`).join('\n')}`
      : '';
    
    return `Security Scan Report
Status: ${status}
Scan Time: ${result.scanTime}ms
File Hash: ${result.fileHash}${threats}`;
  }
}